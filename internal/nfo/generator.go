package nfo

import (
	"fmt"
	"os/exec"
	"strings"
	"time"

	"github.com/metwurcht/torrent-all-in-one/internal/mediainfo"
	"github.com/metwurcht/torrent-all-in-one/internal/tmdb"
)

// Generator génère des fichiers NFO
type Generator struct {
	groupName string
}

// NewGenerator crée un nouveau générateur NFO
func NewGenerator(groupName string) *Generator {
	return &Generator{
		groupName: groupName,
	}
}

const nfoWidth = 120

// Generate génère le contenu du fichier NFO en utilisant MediaInfo
func (g *Generator) Generate(movie *tmdb.Movie, media *mediainfo.MediaInfo, newFileName string) string {
	var sb strings.Builder

	// En-tête avec informations du film
	sb.WriteString(g.generateHeader(movie, newFileName))
	sb.WriteString("\n")

	// Sortie MediaInfo brute
	mediaInfoOutput, err := g.getMediaInfoOutput(media.FilePath)
	if err != nil {
		// Fallback en cas d'erreur: afficher une version basique
		sb.WriteString(fmt.Sprintf("Error getting MediaInfo output: %v\n", err))
		sb.WriteString(fmt.Sprintf("File: %s\n", newFileName))
	} else {
		sb.WriteString(mediaInfoOutput)
	}

	sb.WriteString("\n")

	// Footer avec informations supplémentaires du film
	sb.WriteString(g.generateFooter(movie))

	return sb.String()
}

// getMediaInfoOutput exécute mediainfo et retourne sa sortie brute
func (g *Generator) getMediaInfoOutput(filePath string) (string, error) {
	cmd := exec.Command("mediainfo", filePath)
	output, err := cmd.Output()
	if err != nil {
		return "", fmt.Errorf("failed to run mediainfo: %w", err)
	}

	result := string(output)

	// Remplacer le chemin complet par juste le nom du fichier dans "Complete name"
	lines := strings.Split(result, "\n")
	for i, line := range lines {
		if strings.Contains(line, "Complete name") && strings.Contains(line, ":") {
			parts := strings.SplitN(line, ":", 2)
			if len(parts) == 2 {
				// Extraire juste le nom du fichier
				fileName := strings.TrimSpace(parts[1])
				if strings.Contains(fileName, "/") || strings.Contains(fileName, "\\") {
					fileName = fileName[strings.LastIndex(fileName, "/")+1:]
					if strings.Contains(fileName, "\\") {
						fileName = fileName[strings.LastIndex(fileName, "\\")+1:]
					}
				}
				lines[i] = parts[0] + ": " + fileName
			}
		}
	}

	return strings.Join(lines, "\n"), nil
}

// generateHeader génère l'en-tête du NFO avec les informations du film
func (g *Generator) generateHeader(movie *tmdb.Movie, newFileName string) string {
	border := strings.Repeat("=", nfoWidth)
	thinBorder := strings.Repeat("-", nfoWidth)
	var sb strings.Builder

	sb.WriteString(border + "\n")
	sb.WriteString(g.centerText(g.groupName+" presents", nfoWidth) + "\n")
	sb.WriteString(border + "\n")
	sb.WriteString(g.centerText(movie.Title, nfoWidth) + "\n")
	if movie.OriginalTitle != "" && movie.OriginalTitle != movie.Title {
		sb.WriteString(g.centerText(fmt.Sprintf("(%s)", movie.OriginalTitle), nfoWidth) + "\n")
	}
	sb.WriteString(thinBorder + "\n")
	sb.WriteString(fmt.Sprintf("Release Name: %s\n", newFileName))

	if movie.ReleaseDate != "" {
		sb.WriteString(fmt.Sprintf("Release Date: %s\n", movie.ReleaseDate))
	}
	if len(movie.Genres) > 0 {
		sb.WriteString(fmt.Sprintf("Genre: %s\n", strings.Join(movie.Genres, ", ")))
	}
	if movie.Runtime > 0 {
		sb.WriteString(fmt.Sprintf("Runtime: %d min\n", movie.Runtime))
	}
	if movie.VoteAverage > 0 {
		sb.WriteString(fmt.Sprintf("Rating: %.1f/10\n", movie.VoteAverage))
	}
	if movie.IMDbID != "" {
		sb.WriteString(fmt.Sprintf("IMDb: %s\n", movie.IMDbURL()))
	}
	sb.WriteString(fmt.Sprintf("TMDB: %s\n", movie.TMDbURL()))

	if len(movie.Directors) > 0 {
		sb.WriteString(fmt.Sprintf("Director: %s\n", strings.Join(movie.Directors, ", ")))
	}

	if len(movie.Cast) > 0 {
		actors := make([]string, 0, 5)
		for i, c := range movie.Cast {
			if i >= 5 {
				break
			}
			actors = append(actors, c.Name)
		}
		sb.WriteString(fmt.Sprintf("Cast: %s\n", strings.Join(actors, ", ")))
	}

	sb.WriteString(border + "\n")
	sb.WriteString(g.centerText("SYNOPSIS", nfoWidth) + "\n")
	sb.WriteString(thinBorder + "\n\n")

	if movie.Overview != "" {
		sb.WriteString(g.wrapText(movie.Overview, nfoWidth))
	}

	sb.WriteString("\n")
	sb.WriteString(border + "\n")

	sb.WriteString(g.centerText("MEDIA INFORMATION", nfoWidth) + "\n")
	sb.WriteString(thinBorder + "\n")

	return sb.String()
}

// generateFooter génère le pied de page du NFO avec le synopsis
func (g *Generator) generateFooter(movie *tmdb.Movie) string {

	border := strings.Repeat("=", nfoWidth)
	var sb strings.Builder
	sb.WriteString("\n" + border + "\n")
	sb.WriteString(g.centerText("Generated by Torrent-AIO", nfoWidth) + "\n")
	sb.WriteString(g.centerText(time.Now().Format("2006-01-02 15:04:05"), nfoWidth) + "\n")
	sb.WriteString(border + "\n")

	return sb.String()
}

// centerText centre un texte dans une largeur donnée
func (g *Generator) centerText(text string, width int) string {
	textLen := len(text)
	if textLen >= width {
		return text
	}
	padding := (width - textLen) / 2
	return strings.Repeat(" ", padding) + text
}

// wrapText découpe un texte en lignes de largeur maximale
func (g *Generator) wrapText(text string, width int) string {
	words := strings.Fields(text)
	var lines []string
	var currentLine strings.Builder

	for _, word := range words {
		if currentLine.Len()+len(word)+1 > width {
			if currentLine.Len() > 0 {
				lines = append(lines, currentLine.String())
				currentLine.Reset()
			}
		}
		if currentLine.Len() > 0 {
			currentLine.WriteString(" ")
		}
		currentLine.WriteString(word)
	}
	if currentLine.Len() > 0 {
		lines = append(lines, currentLine.String())
	}

	return strings.Join(lines, "\n") + "\n"
}
